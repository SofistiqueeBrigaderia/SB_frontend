{"ast":null,"code":"import * as React from 'react';\nconst LEFT = \"Left\";\nconst RIGHT = \"Right\";\nconst UP = \"Up\";\nconst DOWN = \"Down\";\n/* global document */\n\nconst defaultProps = {\n  delta: 10,\n  preventScrollOnSwipe: false,\n  rotationAngle: 0,\n  trackMouse: false,\n  trackTouch: true,\n  swipeDuration: Infinity,\n  touchEventOptions: {\n    passive: true\n  }\n};\nconst initialState = {\n  first: true,\n  initial: [0, 0],\n  start: 0,\n  swiping: false,\n  xy: [0, 0]\n};\nconst mouseMove = \"mousemove\";\nconst mouseUp = \"mouseup\";\nconst touchEnd = \"touchend\";\nconst touchMove = \"touchmove\";\nconst touchStart = \"touchstart\";\n\nfunction getDirection(absX, absY, deltaX, deltaY) {\n  if (absX > absY) {\n    if (deltaX > 0) {\n      return RIGHT;\n    }\n\n    return LEFT;\n  } else if (deltaY > 0) {\n    return DOWN;\n  }\n\n  return UP;\n}\n\nfunction rotateXYByAngle(pos, angle) {\n  if (angle === 0) return pos;\n  const angleInRadians = Math.PI / 180 * angle;\n  const x = pos[0] * Math.cos(angleInRadians) + pos[1] * Math.sin(angleInRadians);\n  const y = pos[1] * Math.cos(angleInRadians) - pos[0] * Math.sin(angleInRadians);\n  return [x, y];\n}\n\nfunction getHandlers(set, handlerProps) {\n  const onStart = event => {\n    const isTouch = (\"touches\" in event); // if more than a single touch don't track, for now...\n\n    if (isTouch && event.touches.length > 1) return;\n    set((state, props) => {\n      // setup mouse listeners on document to track swipe since swipe can leave container\n      if (props.trackMouse && !isTouch) {\n        document.addEventListener(mouseMove, onMove);\n        document.addEventListener(mouseUp, onUp);\n      }\n\n      const {\n        clientX,\n        clientY\n      } = isTouch ? event.touches[0] : event;\n      const xy = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n      props.onTouchStartOrOnMouseDown && props.onTouchStartOrOnMouseDown({\n        event\n      });\n      return Object.assign(Object.assign(Object.assign({}, state), initialState), {\n        initial: xy.slice(),\n        xy,\n        start: event.timeStamp || 0\n      });\n    });\n  };\n\n  const onMove = event => {\n    set((state, props) => {\n      const isTouch = (\"touches\" in event); // Discount a swipe if additional touches are present after\n      // a swipe has started.\n\n      if (isTouch && event.touches.length > 1) {\n        return state;\n      } // if swipe has exceeded duration stop tracking\n\n\n      if (event.timeStamp - state.start > props.swipeDuration) {\n        return state.swiping ? Object.assign(Object.assign({}, state), {\n          swiping: false\n        }) : state;\n      }\n\n      const {\n        clientX,\n        clientY\n      } = isTouch ? event.touches[0] : event;\n      const [x, y] = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n      const deltaX = x - state.xy[0];\n      const deltaY = y - state.xy[1];\n      const absX = Math.abs(deltaX);\n      const absY = Math.abs(deltaY);\n      const time = (event.timeStamp || 0) - state.start;\n      const velocity = Math.sqrt(absX * absX + absY * absY) / (time || 1);\n      const vxvy = [deltaX / (time || 1), deltaY / (time || 1)];\n      const dir = getDirection(absX, absY, deltaX, deltaY); // if swipe is under delta and we have not started to track a swipe: skip update\n\n      const delta = typeof props.delta === \"number\" ? props.delta : props.delta[dir.toLowerCase()] || defaultProps.delta;\n      if (absX < delta && absY < delta && !state.swiping) return state;\n      const eventData = {\n        absX,\n        absY,\n        deltaX,\n        deltaY,\n        dir,\n        event,\n        first: state.first,\n        initial: state.initial,\n        velocity,\n        vxvy\n      }; // call onSwipeStart if present and is first swipe event\n\n      eventData.first && props.onSwipeStart && props.onSwipeStart(eventData); // call onSwiping if present\n\n      props.onSwiping && props.onSwiping(eventData); // track if a swipe is cancelable (handler for swiping or swiped(dir) exists)\n      // so we can call preventDefault if needed\n\n      let cancelablePageSwipe = false;\n\n      if (props.onSwiping || props.onSwiped || props[`onSwiped${dir}`]) {\n        cancelablePageSwipe = true;\n      }\n\n      if (cancelablePageSwipe && props.preventScrollOnSwipe && props.trackTouch && event.cancelable) {\n        event.preventDefault();\n      }\n\n      return Object.assign(Object.assign({}, state), {\n        // first is now always false\n        first: false,\n        eventData,\n        swiping: true\n      });\n    });\n  };\n\n  const onEnd = event => {\n    set((state, props) => {\n      let eventData;\n\n      if (state.swiping && state.eventData) {\n        // if swipe is less than duration fire swiped callbacks\n        if (event.timeStamp - state.start < props.swipeDuration) {\n          eventData = Object.assign(Object.assign({}, state.eventData), {\n            event\n          });\n          props.onSwiped && props.onSwiped(eventData);\n          const onSwipedDir = props[`onSwiped${eventData.dir}`];\n          onSwipedDir && onSwipedDir(eventData);\n        }\n      } else {\n        props.onTap && props.onTap({\n          event\n        });\n      }\n\n      props.onTouchEndOrOnMouseUp && props.onTouchEndOrOnMouseUp({\n        event\n      });\n      return Object.assign(Object.assign(Object.assign({}, state), initialState), {\n        eventData\n      });\n    });\n  };\n\n  const cleanUpMouse = () => {\n    // safe to just call removeEventListener\n    document.removeEventListener(mouseMove, onMove);\n    document.removeEventListener(mouseUp, onUp);\n  };\n\n  const onUp = e => {\n    cleanUpMouse();\n    onEnd(e);\n  };\n  /**\n   * The value of passive on touchMove depends on `preventScrollOnSwipe`:\n   * - true => { passive: false }\n   * - false => { passive: true } // Default\n   *\n   * NOTE: When preventScrollOnSwipe is true, we attempt to call preventDefault to prevent scroll.\n   *\n   * props.touchEventOptions can also be set for all touch event listeners,\n   * but for `touchmove` specifically when `preventScrollOnSwipe` it will\n   * supersede and force passive to false.\n   *\n   */\n\n\n  const attachTouch = (el, props) => {\n    let cleanup = () => {};\n\n    if (el && el.addEventListener) {\n      const baseOptions = Object.assign(Object.assign({}, defaultProps.touchEventOptions), props.touchEventOptions); // attach touch event listeners and handlers\n\n      const tls = [[touchStart, onStart, baseOptions], // preventScrollOnSwipe option supersedes touchEventOptions.passive\n      [touchMove, onMove, Object.assign(Object.assign({}, baseOptions), props.preventScrollOnSwipe ? {\n        passive: false\n      } : {})], [touchEnd, onEnd, baseOptions]];\n      tls.forEach(_ref => {\n        let [e, h, o] = _ref;\n        return el.addEventListener(e, h, o);\n      }); // return properly scoped cleanup method for removing listeners, options not required\n\n      cleanup = () => tls.forEach(_ref2 => {\n        let [e, h] = _ref2;\n        return el.removeEventListener(e, h);\n      });\n    }\n\n    return cleanup;\n  };\n\n  const onRef = el => {\n    // \"inline\" ref functions are called twice on render, once with null then again with DOM element\n    // ignore null here\n    if (el === null) return;\n    set((state, props) => {\n      // if the same DOM el as previous just return state\n      if (state.el === el) return state;\n      const addState = {}; // if new DOM el clean up old DOM and reset cleanUpTouch\n\n      if (state.el && state.el !== el && state.cleanUpTouch) {\n        state.cleanUpTouch();\n        addState.cleanUpTouch = void 0;\n      } // only attach if we want to track touch\n\n\n      if (props.trackTouch && el) {\n        addState.cleanUpTouch = attachTouch(el, props);\n      } // store event attached DOM el for comparison, clean up, and re-attachment\n\n\n      return Object.assign(Object.assign(Object.assign({}, state), {\n        el\n      }), addState);\n    });\n  }; // set ref callback to attach touch event listeners\n\n\n  const output = {\n    ref: onRef\n  }; // if track mouse attach mouse down listener\n\n  if (handlerProps.trackMouse) {\n    output.onMouseDown = onStart;\n  }\n\n  return [output, attachTouch];\n}\n\nfunction updateTransientState(state, props, previousProps, attachTouch) {\n  // if trackTouch is off or there is no el, then remove handlers if necessary and exit\n  if (!props.trackTouch || !state.el) {\n    if (state.cleanUpTouch) {\n      state.cleanUpTouch();\n    }\n\n    return Object.assign(Object.assign({}, state), {\n      cleanUpTouch: undefined\n    });\n  } // trackTouch is on, so if there are no handlers attached, attach them and exit\n\n\n  if (!state.cleanUpTouch) {\n    return Object.assign(Object.assign({}, state), {\n      cleanUpTouch: attachTouch(state.el, props)\n    });\n  } // trackTouch is on and handlers are already attached, so if preventScrollOnSwipe changes value,\n  // remove and reattach handlers (this is required to update the passive option when attaching\n  // the handlers)\n\n\n  if (props.preventScrollOnSwipe !== previousProps.preventScrollOnSwipe || props.touchEventOptions.passive !== previousProps.touchEventOptions.passive) {\n    state.cleanUpTouch();\n    return Object.assign(Object.assign({}, state), {\n      cleanUpTouch: attachTouch(state.el, props)\n    });\n  }\n\n  return state;\n}\n\nfunction useSwipeable(options) {\n  const {\n    trackMouse\n  } = options;\n  const transientState = React.useRef(Object.assign({}, initialState));\n  const transientProps = React.useRef(Object.assign({}, defaultProps)); // track previous rendered props\n\n  const previousProps = React.useRef(Object.assign({}, transientProps.current));\n  previousProps.current = Object.assign({}, transientProps.current); // update current render props & defaults\n\n  transientProps.current = Object.assign(Object.assign({}, defaultProps), options); // Force defaults for config properties\n\n  let defaultKey;\n\n  for (defaultKey in defaultProps) {\n    if (transientProps.current[defaultKey] === void 0) {\n      transientProps.current[defaultKey] = defaultProps[defaultKey];\n    }\n  }\n\n  const [handlers, attachTouch] = React.useMemo(() => getHandlers(stateSetter => transientState.current = stateSetter(transientState.current, transientProps.current), {\n    trackMouse\n  }), [trackMouse]);\n  transientState.current = updateTransientState(transientState.current, transientProps.current, previousProps.current, attachTouch);\n  return handlers;\n}\n\nexport { DOWN, LEFT, RIGHT, UP, useSwipeable };","map":{"version":3,"mappings":";MAEaA,IAAI,GAAG;MACPC,KAAK,GAAG;MACRC,EAAE,GAAG;MACLC,IAAI,GAAG;ACLpB;;AAsCA,MAAMC,YAAY,GAAyB;AACzCC,OAAK,EAAE,EADkC;AAEzCC,sBAAoB,EAAE,KAFmB;AAGzCC,eAAa,EAAE,CAH0B;AAIzCC,YAAU,EAAE,KAJ6B;AAKzCC,YAAU,EAAE,IAL6B;AAMzCC,eAAa,EAAEC,QAN0B;AAOzCC,mBAAiB,EAAE;AAAEC,WAAO,EAAE;AAAX;AAPsB,CAA3C;AASA,MAAMC,YAAY,GAAmB;AACnCC,OAAK,EAAE,IAD4B;AAEnCC,SAAO,EAAE,CAAC,CAAD,EAAI,CAAJ,CAF0B;AAGnCC,OAAK,EAAE,CAH4B;AAInCC,SAAO,EAAE,KAJ0B;AAKnCC,IAAE,EAAE,CAAC,CAAD,EAAI,CAAJ;AAL+B,CAArC;AAOA,MAAMC,SAAS,GAAG,WAAlB;AACA,MAAMC,OAAO,GAAG,SAAhB;AACA,MAAMC,QAAQ,GAAG,UAAjB;AACA,MAAMC,SAAS,GAAG,WAAlB;AACA,MAAMC,UAAU,GAAG,YAAnB;;AAEA,SAASC,YAAT,CACEC,IADF,EAEEC,IAFF,EAGEC,MAHF,EAIEC,MAJF,EAIgB;AAEd,MAAIH,IAAI,GAAGC,IAAX,EAAiB;AACf,QAAIC,MAAM,GAAG,CAAb,EAAgB;AACd,aAAO3B,KAAP;AACD;;AACD,WAAOD,IAAP;AACD,GALD,MAKO,IAAI6B,MAAM,GAAG,CAAb,EAAgB;AACrB,WAAO1B,IAAP;AACD;;AACD,SAAOD,EAAP;AACD;;AAED,SAAS4B,eAAT,CAAyBC,GAAzB,EAAuCC,KAAvC,EAAoD;AAClD,MAAIA,KAAK,KAAK,CAAd,EAAiB,OAAOD,GAAP;AACjB,QAAME,cAAc,GAAIC,IAAI,CAACC,EAAL,GAAU,GAAX,GAAkBH,KAAzC;AACA,QAAMI,CAAC,GACLL,GAAG,CAAC,CAAD,CAAH,GAASG,IAAI,CAACG,GAAL,CAASJ,cAAT,CAAT,GAAoCF,GAAG,CAAC,CAAD,CAAH,GAASG,IAAI,CAACI,GAAL,CAASL,cAAT,CAD/C;AAEA,QAAMM,CAAC,GACLR,GAAG,CAAC,CAAD,CAAH,GAASG,IAAI,CAACG,GAAL,CAASJ,cAAT,CAAT,GAAoCF,GAAG,CAAC,CAAD,CAAH,GAASG,IAAI,CAACI,GAAL,CAASL,cAAT,CAD/C;AAEA,SAAO,CAACG,CAAD,EAAIG,CAAJ,CAAP;AACD;;AAED,SAASC,WAAT,CACEC,GADF,EAEEC,YAFF,EAEmD;AAQjD,QAAMC,OAAO,GAAIC,KAAD,IAAqB;AACnC,UAAMC,OAAO,IAAG,aAAaD,KAAhB,CAAb,CADmC;;AAGnC,QAAIC,OAAO,IAAID,KAAK,CAACE,OAAN,CAAcC,MAAd,GAAuB,CAAtC,EAAyC;AAEzCN,OAAG,CAAC,CAACO,KAAD,EAAQC,KAAR,KAAa;;AAEf,UAAIA,KAAK,CAACzC,UAAN,IAAoB,CAACqC,OAAzB,EAAkC;AAChCK,gBAAQ,CAACC,gBAAT,CAA0B/B,SAA1B,EAAqCgC,MAArC;AACAF,gBAAQ,CAACC,gBAAT,CAA0B9B,OAA1B,EAAmCgC,IAAnC;AACD;;AACD,YAAM;AAAEC,eAAF;AAAWC;AAAX,UAAuBV,OAAO,GAAGD,KAAK,CAACE,OAAN,CAAc,CAAd,CAAH,GAAsBF,KAA1D;AACA,YAAMzB,EAAE,GAAGW,eAAe,CAAC,CAACwB,OAAD,EAAUC,OAAV,CAAD,EAAqBN,KAAK,CAAC1C,aAA3B,CAA1B;AAEA0C,WAAK,CAACO,yBAAN,IACEP,KAAK,CAACO,yBAAN,CAAgC;AAAEZ;AAAF,OAAhC,CADF;AAGA,2DACKI,KADL,GAEKlC,YAFL,GAEiB;AACfE,eAAO,EAAEG,EAAE,CAACsC,KAAH,EADM;AAEftC,UAFe;AAGfF,aAAK,EAAE2B,KAAK,CAACc,SAAN,IAAmB;AAHX,OAFjB;AAOD,KAnBE,CAAH;AAoBD,GAzBD;;AA2BA,QAAMN,MAAM,GAAIR,KAAD,IAAqB;AAClCH,OAAG,CAAC,CAACO,KAAD,EAAQC,KAAR,KAAa;AACf,YAAMJ,OAAO,IAAG,aAAaD,KAAhB,CAAb,CADe;;;AAIf,UAAIC,OAAO,IAAID,KAAK,CAACE,OAAN,CAAcC,MAAd,GAAuB,CAAtC,EAAyC;AACvC,eAAOC,KAAP;AACD,OANc;;;AASf,UAAIJ,KAAK,CAACc,SAAN,GAAkBV,KAAK,CAAC/B,KAAxB,GAAgCgC,KAAK,CAACvC,aAA1C,EAAyD;AACvD,eAAOsC,KAAK,CAAC9B,OAAN,GAAayC,gCAAQX,KAAR,GAAa;AAAE9B,iBAAO,EAAE;AAAX,SAAb,CAAb,GAA+C8B,KAAtD;AACD;;AAED,YAAM;AAAEM,eAAF;AAAWC;AAAX,UAAuBV,OAAO,GAAGD,KAAK,CAACE,OAAN,CAAc,CAAd,CAAH,GAAsBF,KAA1D;AACA,YAAM,CAACR,CAAD,EAAIG,CAAJ,IAAST,eAAe,CAAC,CAACwB,OAAD,EAAUC,OAAV,CAAD,EAAqBN,KAAK,CAAC1C,aAA3B,CAA9B;AACA,YAAMqB,MAAM,GAAGQ,CAAC,GAAGY,KAAK,CAAC7B,EAAN,CAAS,CAAT,CAAnB;AACA,YAAMU,MAAM,GAAGU,CAAC,GAAGS,KAAK,CAAC7B,EAAN,CAAS,CAAT,CAAnB;AACA,YAAMO,IAAI,GAAGQ,IAAI,CAAC0B,GAAL,CAAShC,MAAT,CAAb;AACA,YAAMD,IAAI,GAAGO,IAAI,CAAC0B,GAAL,CAAS/B,MAAT,CAAb;AACA,YAAMgC,IAAI,GAAG,CAACjB,KAAK,CAACc,SAAN,IAAmB,CAApB,IAAyBV,KAAK,CAAC/B,KAA5C;AACA,YAAM6C,QAAQ,GAAG5B,IAAI,CAAC6B,IAAL,CAAUrC,IAAI,GAAGA,IAAP,GAAcC,IAAI,GAAGA,IAA/B,KAAwCkC,IAAI,IAAI,CAAhD,CAAjB;AACA,YAAMG,IAAI,GAAY,CAACpC,MAAM,IAAIiC,IAAI,IAAI,CAAZ,CAAP,EAAuBhC,MAAM,IAAIgC,IAAI,IAAI,CAAZ,CAA7B,CAAtB;AAEA,YAAMI,GAAG,GAAGxC,YAAY,CAACC,IAAD,EAAOC,IAAP,EAAaC,MAAb,EAAqBC,MAArB,CAAxB,CAvBe;;AA0Bf,YAAMxB,KAAK,GACT,OAAO4C,KAAK,CAAC5C,KAAb,KAAuB,QAAvB,GACI4C,KAAK,CAAC5C,KADV,GAEI4C,KAAK,CAAC5C,KAAN,CAAY4D,GAAG,CAACC,WAAJ,EAAZ,KACA9D,YAAY,CAACC,KAJnB;AAKA,UAAIqB,IAAI,GAAGrB,KAAP,IAAgBsB,IAAI,GAAGtB,KAAvB,IAAgC,CAAC2C,KAAK,CAAC9B,OAA3C,EAAoD,OAAO8B,KAAP;AAEpD,YAAMmB,SAAS,GAAG;AAChBzC,YADgB;AAEhBC,YAFgB;AAGhBC,cAHgB;AAIhBC,cAJgB;AAKhBoC,WALgB;AAMhBrB,aANgB;AAOhB7B,aAAK,EAAEiC,KAAK,CAACjC,KAPG;AAQhBC,eAAO,EAAEgC,KAAK,CAAChC,OARC;AAShB8C,gBATgB;AAUhBE;AAVgB,OAAlB,CAjCe;;AA+CfG,eAAS,CAACpD,KAAV,IAAmBkC,KAAK,CAACmB,YAAzB,IAAyCnB,KAAK,CAACmB,YAAN,CAAmBD,SAAnB,CAAzC,CA/Ce;;AAkDflB,WAAK,CAACoB,SAAN,IAAmBpB,KAAK,CAACoB,SAAN,CAAgBF,SAAhB,CAAnB,CAlDe;;;AAsDf,UAAIG,mBAAmB,GAAG,KAA1B;;AACA,UACErB,KAAK,CAACoB,SAAN,IACApB,KAAK,CAACsB,QADN,IAEAtB,KAAK,CAAC,WAAWgB,GAAG,EAAf,CAHP,EAIE;AACAK,2BAAmB,GAAG,IAAtB;AACD;;AAED,UACEA,mBAAmB,IACnBrB,KAAK,CAAC3C,oBADN,IAEA2C,KAAK,CAACxC,UAFN,IAGAmC,KAAK,CAAC4B,UAJR,EAKE;AACA5B,aAAK,CAAC6B,cAAN;AACD;;AAED,6CACKzB,KADL,GACU;;AAERjC,aAAK,EAAE,KAFC;AAGRoD,iBAHQ;AAIRjD,eAAO,EAAE;AAJD,OADV;AAOD,KA/EE,CAAH;AAgFD,GAjFD;;AAmFA,QAAMwD,KAAK,GAAI9B,KAAD,IAAqB;AACjCH,OAAG,CAAC,CAACO,KAAD,EAAQC,KAAR,KAAa;AACf,UAAIkB,SAAJ;;AACA,UAAInB,KAAK,CAAC9B,OAAN,IAAiB8B,KAAK,CAACmB,SAA3B,EAAsC;;AAEpC,YAAIvB,KAAK,CAACc,SAAN,GAAkBV,KAAK,CAAC/B,KAAxB,GAAgCgC,KAAK,CAACvC,aAA1C,EAAyD;AACvDyD,mBAAS,mCAAQnB,KAAK,CAACmB,SAAd,GAAuB;AAAEvB;AAAF,WAAvB,CAAT;AACAK,eAAK,CAACsB,QAAN,IAAkBtB,KAAK,CAACsB,QAAN,CAAeJ,SAAf,CAAlB;AAEA,gBAAMQ,WAAW,GACf1B,KAAK,CACH,WAAWkB,SAAS,CAACF,GAAG,EADrB,CADP;AAIAU,qBAAW,IAAIA,WAAW,CAACR,SAAD,CAA1B;AACD;AACF,OAZD,MAYO;AACLlB,aAAK,CAAC2B,KAAN,IAAe3B,KAAK,CAAC2B,KAAN,CAAY;AAAEhC;AAAF,SAAZ,CAAf;AACD;;AAEDK,WAAK,CAAC4B,qBAAN,IAA+B5B,KAAK,CAAC4B,qBAAN,CAA4B;AAAEjC;AAAF,OAA5B,CAA/B;AAEA,2DAAYI,KAAZ,GAAsBlC,YAAtB,GAAkC;AAAEqD;AAAF,OAAlC;AACD,KArBE,CAAH;AAsBD,GAvBD;;AAyBA,QAAMW,YAAY,GAAG;;AAEnB5B,YAAQ,CAAC6B,mBAAT,CAA6B3D,SAA7B,EAAwCgC,MAAxC;AACAF,YAAQ,CAAC6B,mBAAT,CAA6B1D,OAA7B,EAAsCgC,IAAtC;AACD,GAJD;;AAMA,QAAMA,IAAI,GAAI2B,CAAD,IAAiB;AAC5BF,gBAAY;AACZJ,SAAK,CAACM,CAAD,CAAL;AACD,GAHD;;;;;;;;;;;;;;;AAiBA,QAAMC,WAAW,GAAgB,CAACC,EAAD,EAAKjC,KAAL,KAAU;AACzC,QAAIkC,OAAO,GAAG,OAAQ,CAAtB;;AACA,QAAID,EAAE,IAAIA,EAAE,CAAC/B,gBAAb,EAA+B;AAC7B,YAAMiC,WAAW,mCACZhF,YAAY,CAACQ,iBADD,GAEZqC,KAAK,CAACrC,iBAFM,CAAjB,CAD6B;;AAM7B,YAAMyE,GAAG,GAIH,CACJ,CAAC7D,UAAD,EAAamB,OAAb,EAAsByC,WAAtB,CADI;AAGJ,OACE7D,SADF,EAEE6B,MAFF,kCAIOgC,cACCnC,KAAK,CAAC3C,oBAAN,GAA6B;AAAEO,eAAO,EAAE;AAAX,OAA7B,GAAkD,GAL1D,CAHI,EAWJ,CAACS,QAAD,EAAWoD,KAAX,EAAkBU,WAAlB,CAXI,CAJN;AAiBAC,SAAG,CAACC,OAAJ,CAAY;AAAA,YAAC,CAACN,CAAD,EAAIO,CAAJ,EAAOC,CAAP,CAAD;AAAA,eAAeN,EAAE,CAAC/B,gBAAH,CAAoB6B,CAApB,EAAuBO,CAAvB,EAA0BC,CAA1B,CAAf;AAAA,OAAZ,EAvB6B;;AAyB7BL,aAAO,GAAG,MAAME,GAAG,CAACC,OAAJ,CAAY;AAAA,YAAC,CAACN,CAAD,EAAIO,CAAJ,CAAD;AAAA,eAAYL,EAAE,CAACH,mBAAH,CAAuBC,CAAvB,EAA0BO,CAA1B,CAAZ;AAAA,OAAZ,CAAhB;AACD;;AACD,WAAOJ,OAAP;AACD,GA9BD;;AAgCA,QAAMM,KAAK,GAAIP,EAAD,IAAuB;;;AAGnC,QAAIA,EAAE,KAAK,IAAX,EAAiB;AACjBzC,OAAG,CAAC,CAACO,KAAD,EAAQC,KAAR,KAAa;;AAEf,UAAID,KAAK,CAACkC,EAAN,KAAaA,EAAjB,EAAqB,OAAOlC,KAAP;AAErB,YAAM0C,QAAQ,GAAkC,EAAhD,CAJe;;AAMf,UAAI1C,KAAK,CAACkC,EAAN,IAAYlC,KAAK,CAACkC,EAAN,KAAaA,EAAzB,IAA+BlC,KAAK,CAAC2C,YAAzC,EAAuD;AACrD3C,aAAK,CAAC2C,YAAN;AACAD,gBAAQ,CAACC,YAAT,GAAwB,KAAK,CAA7B;AACD,OATc;;;AAWf,UAAI1C,KAAK,CAACxC,UAAN,IAAoByE,EAAxB,EAA4B;AAC1BQ,gBAAQ,CAACC,YAAT,GAAwBV,WAAW,CAACC,EAAD,EAAKjC,KAAL,CAAnC;AACD,OAbc;;;AAgBf,2DAAYD,KAAZ,GAAiB;AAAEkC;AAAF,OAAjB,GAA0BQ,QAA1B;AACD,KAjBE,CAAH;AAkBD,GAtBD,CAtMiD;;;AA+NjD,QAAME,MAAM,GAAwD;AAClEC,OAAG,EAAEJ;AAD6D,GAApE,CA/NiD;;AAoOjD,MAAI/C,YAAY,CAAClC,UAAjB,EAA6B;AAC3BoF,UAAM,CAACE,WAAP,GAAqBnD,OAArB;AACD;;AAED,SAAO,CAACiD,MAAD,EAASX,WAAT,CAAP;AACD;;AAED,SAASc,oBAAT,CACE/C,KADF,EAEEC,KAFF,EAGE+C,aAHF,EAIEf,WAJF,EAI0B;;AAGxB,MAAI,CAAChC,KAAK,CAACxC,UAAP,IAAqB,CAACuC,KAAK,CAACkC,EAAhC,EAAoC;AAClC,QAAIlC,KAAK,CAAC2C,YAAV,EAAwB;AACtB3C,WAAK,CAAC2C,YAAN;AACD;;AAED,2CACK3C,KADL,GACU;AACR2C,kBAAY,EAAEM;AADN,KADV;AAID,GAZuB;;;AAexB,MAAI,CAACjD,KAAK,CAAC2C,YAAX,EAAyB;AACvB,2CACK3C,KADL,GACU;AACR2C,kBAAY,EAAEV,WAAW,CAACjC,KAAK,CAACkC,EAAP,EAAWjC,KAAX;AADjB,KADV;AAID,GApBuB;;;;;AAyBxB,MACEA,KAAK,CAAC3C,oBAAN,KAA+B0F,aAAa,CAAC1F,oBAA7C,IACA2C,KAAK,CAACrC,iBAAN,CAAwBC,OAAxB,KAAoCmF,aAAa,CAACpF,iBAAd,CAAgCC,OAFtE,EAGE;AACAmC,SAAK,CAAC2C,YAAN;AAEA,2CACK3C,KADL,GACU;AACR2C,kBAAY,EAAEV,WAAW,CAACjC,KAAK,CAACkC,EAAP,EAAWjC,KAAX;AADjB,KADV;AAID;;AAED,SAAOD,KAAP;AACD;;SAEekD,aAAaC,SAAuB;AAClD,QAAM;AAAE3F;AAAF,MAAiB2F,OAAvB;AACA,QAAMC,cAAc,GAAGC,KAAK,CAACC,MAAN,CAAY3C,kBAAM7C,YAAN,CAAZ,CAAvB;AACA,QAAMyF,cAAc,GAAGF,KAAK,CAACC,MAAN,CAAY3C,kBAC9BvD,YAD8B,CAAZ,CAAvB,CAHkD;;AAQlD,QAAM4F,aAAa,GAAGK,KAAK,CAACC,MAAN,CAAY3C,kBAC7B4C,cAAc,CAACC,OADc,CAAZ,CAAtB;AAGAR,eAAa,CAACQ,OAAd,GAAqB7C,kBAAQ4C,cAAc,CAACC,OAAvB,CAArB,CAXkD;;AAclDD,gBAAc,CAACC,OAAf,GAAsB7C,gCACjBvD,YADiB,GAEjB+F,OAFiB,CAAtB,CAdkD;;AAmBlD,MAAIM,UAAJ;;AACA,OAAKA,UAAL,IAAmBrG,YAAnB,EAAiC;AAC/B,QAAImG,cAAc,CAACC,OAAf,CAAuBC,UAAvB,MAAuC,KAAK,CAAhD,EAAmD;AAChDF,oBAAc,CAACC,OAAf,CAAuBC,UAAvB,IAA6CrG,YAAY,CAACqG,UAAD,CAAzD;AACF;AACF;;AAED,QAAM,CAACC,QAAD,EAAWzB,WAAX,IAA0BoB,KAAK,CAACM,OAAN,CAC9B,MACEnE,WAAW,CACRoE,WAAD,IACGR,cAAc,CAACI,OAAf,GAAyBI,WAAW,CACnCR,cAAc,CAACI,OADoB,EAEnCD,cAAc,CAACC,OAFoB,CAF9B,EAMT;AAAEhG;AAAF,GANS,CAFiB,EAU9B,CAACA,UAAD,CAV8B,CAAhC;AAaA4F,gBAAc,CAACI,OAAf,GAAyBT,oBAAoB,CAC3CK,cAAc,CAACI,OAD4B,EAE3CD,cAAc,CAACC,OAF4B,EAG3CR,aAAa,CAACQ,OAH6B,EAI3CvB,WAJ2C,CAA7C;AAOA,SAAOyB,QAAP;AACF","names":["LEFT","RIGHT","UP","DOWN","defaultProps","delta","preventScrollOnSwipe","rotationAngle","trackMouse","trackTouch","swipeDuration","Infinity","touchEventOptions","passive","initialState","first","initial","start","swiping","xy","mouseMove","mouseUp","touchEnd","touchMove","touchStart","getDirection","absX","absY","deltaX","deltaY","rotateXYByAngle","pos","angle","angleInRadians","Math","PI","x","cos","sin","y","getHandlers","set","handlerProps","onStart","event","isTouch","touches","length","state","props","document","addEventListener","onMove","onUp","clientX","clientY","onTouchStartOrOnMouseDown","slice","timeStamp","Object","abs","time","velocity","sqrt","vxvy","dir","toLowerCase","eventData","onSwipeStart","onSwiping","cancelablePageSwipe","onSwiped","cancelable","preventDefault","onEnd","onSwipedDir","onTap","onTouchEndOrOnMouseUp","cleanUpMouse","removeEventListener","e","attachTouch","el","cleanup","baseOptions","tls","forEach","h","o","onRef","addState","cleanUpTouch","output","ref","onMouseDown","updateTransientState","previousProps","undefined","useSwipeable","options","transientState","React","useRef","transientProps","current","defaultKey","handlers","useMemo","stateSetter"],"sources":["C:\\Users\\maria\\OneDrive\\Documentos\\VS Code\\app-sofistiquee\\node_modules\\react-swipeable\\src\\types.ts","C:\\Users\\maria\\OneDrive\\Documentos\\VS Code\\app-sofistiquee\\node_modules\\react-swipeable\\src\\index.ts"],"sourcesContent":["import * as React from \"react\";\n\nexport const LEFT = \"Left\";\nexport const RIGHT = \"Right\";\nexport const UP = \"Up\";\nexport const DOWN = \"Down\";\nexport type HandledEvents = React.MouseEvent | TouchEvent | MouseEvent;\nexport type Vector2 = [number, number];\nexport type SwipeDirections =\n  | typeof LEFT\n  | typeof RIGHT\n  | typeof UP\n  | typeof DOWN;\nexport interface SwipeEventData {\n  /**\n   * Absolute displacement of swipe in x. Math.abs(deltaX);\n   */\n  absX: number;\n  /**\n   * Absolute displacement of swipe in y. Math.abs(deltaY);\n   */\n  absY: number;\n  /**\n   * Displacement of swipe in x. (current.x - initial.x)\n   */\n  deltaX: number;\n  /**\n   * Displacement of swipe in y. (current.y - initial.y)\n   */\n  deltaY: number;\n  /**\n   * Direction of swipe - Left | Right | Up | Down\n   */\n  dir: SwipeDirections;\n  /**\n   * Source event.\n   */\n  event: HandledEvents;\n  /**\n   * True for the first event of a tracked swipe.\n   */\n  first: boolean;\n  /**\n   * Location where swipe started - [x, y].\n   */\n  initial: Vector2;\n  /**\n   * \"Absolute velocity\" (speed) - √(absX^2 + absY^2) / time\n   */\n  velocity: number;\n  /**\n   * Velocity per axis - [ deltaX/time, deltaY/time ]\n   */\n  vxvy: Vector2;\n}\n\nexport type SwipeCallback = (eventData: SwipeEventData) => void;\nexport type TapCallback = ({ event }: { event: HandledEvents }) => void;\n\nexport type SwipeableDirectionCallbacks = {\n  /**\n   * Called after a DOWN swipe\n   */\n  onSwipedDown: SwipeCallback;\n  /**\n   * Called after a LEFT swipe\n   */\n  onSwipedLeft: SwipeCallback;\n  /**\n   * Called after a RIGHT swipe\n   */\n  onSwipedRight: SwipeCallback;\n  /**\n   * Called after a UP swipe\n   */\n  onSwipedUp: SwipeCallback;\n};\n\nexport type SwipeableCallbacks = SwipeableDirectionCallbacks & {\n  /**\n   * Called at start of a tracked swipe.\n   */\n  onSwipeStart: SwipeCallback;\n  /**\n   * Called after any swipe.\n   */\n  onSwiped: SwipeCallback;\n  /**\n   * Called for each move event during a tracked swipe.\n   */\n  onSwiping: SwipeCallback;\n  /**\n   * Called after a tap. A touch under the min distance, `delta`.\n   */\n  onTap: TapCallback;\n  /**\n   * Called for `touchstart` and `mousedown`.\n   */\n  onTouchStartOrOnMouseDown: TapCallback;\n  /**\n   * Called for `touchend` and `mouseup`.\n   */\n  onTouchEndOrOnMouseUp: TapCallback;\n};\n\n// Configuration Options\nexport type ConfigurationOptionDelta =\n  | number\n  | { [key in Lowercase<SwipeDirections>]?: number };\n\nexport interface ConfigurationOptions {\n  /**\n   * Min distance(px) before a swipe starts. **Default**: `10`\n   */\n  delta: ConfigurationOptionDelta;\n  /**\n   * Prevents scroll during swipe in most cases. **Default**: `false`\n   */\n  preventScrollOnSwipe: boolean;\n  /**\n   * Set a rotation angle. **Default**: `0`\n   */\n  rotationAngle: number;\n  /**\n   * Track mouse input. **Default**: `false`\n   */\n  trackMouse: boolean;\n  /**\n   * Track touch input. **Default**: `true`\n   */\n  trackTouch: boolean;\n  /**\n   * Allowable duration of a swipe (ms). **Default**: `Infinity`\n   */\n  swipeDuration: number;\n  /**\n   * Options for touch event listeners\n   */\n  touchEventOptions: { passive: boolean };\n}\n\nexport type SwipeableProps = Partial<SwipeableCallbacks & ConfigurationOptions>;\n\nexport type SwipeablePropsWithDefaultOptions = Partial<SwipeableCallbacks> &\n  ConfigurationOptions;\n\nexport interface SwipeableHandlers {\n  ref(element: HTMLElement | null): void;\n  onMouseDown?(event: React.MouseEvent): void;\n}\n\nexport type SwipeableState = {\n  cleanUpTouch?: () => void;\n  el?: HTMLElement;\n  eventData?: SwipeEventData;\n  first: boolean;\n  initial: Vector2;\n  start: number;\n  swiping: boolean;\n  xy: Vector2;\n};\n\nexport type StateSetter = (\n  state: SwipeableState,\n  props: SwipeablePropsWithDefaultOptions\n) => SwipeableState;\nexport type Setter = (stateSetter: StateSetter) => void;\nexport type AttachTouch = (\n  el: HTMLElement,\n  props: SwipeablePropsWithDefaultOptions\n) => () => void;\n","/* global document */\nimport * as React from \"react\";\nimport {\n  AttachTouch,\n  SwipeDirections,\n  DOWN,\n  SwipeEventData,\n  HandledEvents,\n  LEFT,\n  RIGHT,\n  Setter,\n  ConfigurationOptions,\n  SwipeableDirectionCallbacks,\n  SwipeableHandlers,\n  SwipeableProps,\n  SwipeablePropsWithDefaultOptions,\n  SwipeableState,\n  SwipeCallback,\n  TapCallback,\n  UP,\n  Vector2,\n} from \"./types\";\n\nexport {\n  LEFT,\n  RIGHT,\n  UP,\n  DOWN,\n  SwipeDirections,\n  SwipeEventData,\n  SwipeableDirectionCallbacks,\n  SwipeCallback,\n  TapCallback,\n  SwipeableHandlers,\n  SwipeableProps,\n  Vector2,\n};\n\nconst defaultProps: ConfigurationOptions = {\n  delta: 10,\n  preventScrollOnSwipe: false,\n  rotationAngle: 0,\n  trackMouse: false,\n  trackTouch: true,\n  swipeDuration: Infinity,\n  touchEventOptions: { passive: true },\n};\nconst initialState: SwipeableState = {\n  first: true,\n  initial: [0, 0],\n  start: 0,\n  swiping: false,\n  xy: [0, 0],\n};\nconst mouseMove = \"mousemove\";\nconst mouseUp = \"mouseup\";\nconst touchEnd = \"touchend\";\nconst touchMove = \"touchmove\";\nconst touchStart = \"touchstart\";\n\nfunction getDirection(\n  absX: number,\n  absY: number,\n  deltaX: number,\n  deltaY: number\n): SwipeDirections {\n  if (absX > absY) {\n    if (deltaX > 0) {\n      return RIGHT;\n    }\n    return LEFT;\n  } else if (deltaY > 0) {\n    return DOWN;\n  }\n  return UP;\n}\n\nfunction rotateXYByAngle(pos: Vector2, angle: number): Vector2 {\n  if (angle === 0) return pos;\n  const angleInRadians = (Math.PI / 180) * angle;\n  const x =\n    pos[0] * Math.cos(angleInRadians) + pos[1] * Math.sin(angleInRadians);\n  const y =\n    pos[1] * Math.cos(angleInRadians) - pos[0] * Math.sin(angleInRadians);\n  return [x, y];\n}\n\nfunction getHandlers(\n  set: Setter,\n  handlerProps: { trackMouse: boolean | undefined }\n): [\n  {\n    ref: (element: HTMLElement | null) => void;\n    onMouseDown?: (event: React.MouseEvent) => void;\n  },\n  AttachTouch\n] {\n  const onStart = (event: HandledEvents) => {\n    const isTouch = \"touches\" in event;\n    // if more than a single touch don't track, for now...\n    if (isTouch && event.touches.length > 1) return;\n\n    set((state, props) => {\n      // setup mouse listeners on document to track swipe since swipe can leave container\n      if (props.trackMouse && !isTouch) {\n        document.addEventListener(mouseMove, onMove);\n        document.addEventListener(mouseUp, onUp);\n      }\n      const { clientX, clientY } = isTouch ? event.touches[0] : event;\n      const xy = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n\n      props.onTouchStartOrOnMouseDown &&\n        props.onTouchStartOrOnMouseDown({ event });\n\n      return {\n        ...state,\n        ...initialState,\n        initial: xy.slice() as Vector2,\n        xy,\n        start: event.timeStamp || 0,\n      };\n    });\n  };\n\n  const onMove = (event: HandledEvents) => {\n    set((state, props) => {\n      const isTouch = \"touches\" in event;\n      // Discount a swipe if additional touches are present after\n      // a swipe has started.\n      if (isTouch && event.touches.length > 1) {\n        return state;\n      }\n\n      // if swipe has exceeded duration stop tracking\n      if (event.timeStamp - state.start > props.swipeDuration) {\n        return state.swiping ? { ...state, swiping: false } : state;\n      }\n\n      const { clientX, clientY } = isTouch ? event.touches[0] : event;\n      const [x, y] = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n      const deltaX = x - state.xy[0];\n      const deltaY = y - state.xy[1];\n      const absX = Math.abs(deltaX);\n      const absY = Math.abs(deltaY);\n      const time = (event.timeStamp || 0) - state.start;\n      const velocity = Math.sqrt(absX * absX + absY * absY) / (time || 1);\n      const vxvy: Vector2 = [deltaX / (time || 1), deltaY / (time || 1)];\n\n      const dir = getDirection(absX, absY, deltaX, deltaY);\n\n      // if swipe is under delta and we have not started to track a swipe: skip update\n      const delta =\n        typeof props.delta === \"number\"\n          ? props.delta\n          : props.delta[dir.toLowerCase() as Lowercase<SwipeDirections>] ||\n            defaultProps.delta;\n      if (absX < delta && absY < delta && !state.swiping) return state;\n\n      const eventData = {\n        absX,\n        absY,\n        deltaX,\n        deltaY,\n        dir,\n        event,\n        first: state.first,\n        initial: state.initial,\n        velocity,\n        vxvy,\n      };\n\n      // call onSwipeStart if present and is first swipe event\n      eventData.first && props.onSwipeStart && props.onSwipeStart(eventData);\n\n      // call onSwiping if present\n      props.onSwiping && props.onSwiping(eventData);\n\n      // track if a swipe is cancelable (handler for swiping or swiped(dir) exists)\n      // so we can call preventDefault if needed\n      let cancelablePageSwipe = false;\n      if (\n        props.onSwiping ||\n        props.onSwiped ||\n        props[`onSwiped${dir}` as keyof SwipeableDirectionCallbacks]\n      ) {\n        cancelablePageSwipe = true;\n      }\n\n      if (\n        cancelablePageSwipe &&\n        props.preventScrollOnSwipe &&\n        props.trackTouch &&\n        event.cancelable\n      ) {\n        event.preventDefault();\n      }\n\n      return {\n        ...state,\n        // first is now always false\n        first: false,\n        eventData,\n        swiping: true,\n      };\n    });\n  };\n\n  const onEnd = (event: HandledEvents) => {\n    set((state, props) => {\n      let eventData: SwipeEventData | undefined;\n      if (state.swiping && state.eventData) {\n        // if swipe is less than duration fire swiped callbacks\n        if (event.timeStamp - state.start < props.swipeDuration) {\n          eventData = { ...state.eventData, event };\n          props.onSwiped && props.onSwiped(eventData);\n\n          const onSwipedDir =\n            props[\n              `onSwiped${eventData.dir}` as keyof SwipeableDirectionCallbacks\n            ];\n          onSwipedDir && onSwipedDir(eventData);\n        }\n      } else {\n        props.onTap && props.onTap({ event });\n      }\n\n      props.onTouchEndOrOnMouseUp && props.onTouchEndOrOnMouseUp({ event });\n\n      return { ...state, ...initialState, eventData };\n    });\n  };\n\n  const cleanUpMouse = () => {\n    // safe to just call removeEventListener\n    document.removeEventListener(mouseMove, onMove);\n    document.removeEventListener(mouseUp, onUp);\n  };\n\n  const onUp = (e: HandledEvents) => {\n    cleanUpMouse();\n    onEnd(e);\n  };\n\n  /**\n   * The value of passive on touchMove depends on `preventScrollOnSwipe`:\n   * - true => { passive: false }\n   * - false => { passive: true } // Default\n   *\n   * NOTE: When preventScrollOnSwipe is true, we attempt to call preventDefault to prevent scroll.\n   *\n   * props.touchEventOptions can also be set for all touch event listeners,\n   * but for `touchmove` specifically when `preventScrollOnSwipe` it will\n   * supersede and force passive to false.\n   *\n   */\n  const attachTouch: AttachTouch = (el, props) => {\n    let cleanup = () => {};\n    if (el && el.addEventListener) {\n      const baseOptions = {\n        ...defaultProps.touchEventOptions,\n        ...props.touchEventOptions,\n      };\n      // attach touch event listeners and handlers\n      const tls: [\n        typeof touchStart | typeof touchMove | typeof touchEnd,\n        (e: HandledEvents) => void,\n        { passive: boolean }\n      ][] = [\n        [touchStart, onStart, baseOptions],\n        // preventScrollOnSwipe option supersedes touchEventOptions.passive\n        [\n          touchMove,\n          onMove,\n          {\n            ...baseOptions,\n            ...(props.preventScrollOnSwipe ? { passive: false } : {}),\n          },\n        ],\n        [touchEnd, onEnd, baseOptions],\n      ];\n      tls.forEach(([e, h, o]) => el.addEventListener(e, h, o));\n      // return properly scoped cleanup method for removing listeners, options not required\n      cleanup = () => tls.forEach(([e, h]) => el.removeEventListener(e, h));\n    }\n    return cleanup;\n  };\n\n  const onRef = (el: HTMLElement | null) => {\n    // \"inline\" ref functions are called twice on render, once with null then again with DOM element\n    // ignore null here\n    if (el === null) return;\n    set((state, props) => {\n      // if the same DOM el as previous just return state\n      if (state.el === el) return state;\n\n      const addState: { cleanUpTouch?: () => void } = {};\n      // if new DOM el clean up old DOM and reset cleanUpTouch\n      if (state.el && state.el !== el && state.cleanUpTouch) {\n        state.cleanUpTouch();\n        addState.cleanUpTouch = void 0;\n      }\n      // only attach if we want to track touch\n      if (props.trackTouch && el) {\n        addState.cleanUpTouch = attachTouch(el, props);\n      }\n\n      // store event attached DOM el for comparison, clean up, and re-attachment\n      return { ...state, el, ...addState };\n    });\n  };\n\n  // set ref callback to attach touch event listeners\n  const output: { ref: typeof onRef; onMouseDown?: typeof onStart } = {\n    ref: onRef,\n  };\n\n  // if track mouse attach mouse down listener\n  if (handlerProps.trackMouse) {\n    output.onMouseDown = onStart;\n  }\n\n  return [output, attachTouch];\n}\n\nfunction updateTransientState(\n  state: SwipeableState,\n  props: SwipeablePropsWithDefaultOptions,\n  previousProps: SwipeablePropsWithDefaultOptions,\n  attachTouch: AttachTouch\n) {\n  // if trackTouch is off or there is no el, then remove handlers if necessary and exit\n  if (!props.trackTouch || !state.el) {\n    if (state.cleanUpTouch) {\n      state.cleanUpTouch();\n    }\n\n    return {\n      ...state,\n      cleanUpTouch: undefined,\n    };\n  }\n\n  // trackTouch is on, so if there are no handlers attached, attach them and exit\n  if (!state.cleanUpTouch) {\n    return {\n      ...state,\n      cleanUpTouch: attachTouch(state.el, props),\n    };\n  }\n\n  // trackTouch is on and handlers are already attached, so if preventScrollOnSwipe changes value,\n  // remove and reattach handlers (this is required to update the passive option when attaching\n  // the handlers)\n  if (\n    props.preventScrollOnSwipe !== previousProps.preventScrollOnSwipe ||\n    props.touchEventOptions.passive !== previousProps.touchEventOptions.passive\n  ) {\n    state.cleanUpTouch();\n\n    return {\n      ...state,\n      cleanUpTouch: attachTouch(state.el, props),\n    };\n  }\n\n  return state;\n}\n\nexport function useSwipeable(options: SwipeableProps): SwipeableHandlers {\n  const { trackMouse } = options;\n  const transientState = React.useRef({ ...initialState });\n  const transientProps = React.useRef<SwipeablePropsWithDefaultOptions>({\n    ...defaultProps,\n  });\n\n  // track previous rendered props\n  const previousProps = React.useRef<SwipeablePropsWithDefaultOptions>({\n    ...transientProps.current,\n  });\n  previousProps.current = { ...transientProps.current };\n\n  // update current render props & defaults\n  transientProps.current = {\n    ...defaultProps,\n    ...options,\n  };\n  // Force defaults for config properties\n  let defaultKey: keyof ConfigurationOptions;\n  for (defaultKey in defaultProps) {\n    if (transientProps.current[defaultKey] === void 0) {\n      (transientProps.current[defaultKey] as any) = defaultProps[defaultKey];\n    }\n  }\n\n  const [handlers, attachTouch] = React.useMemo(\n    () =>\n      getHandlers(\n        (stateSetter) =>\n          (transientState.current = stateSetter(\n            transientState.current,\n            transientProps.current\n          )),\n        { trackMouse }\n      ),\n    [trackMouse]\n  );\n\n  transientState.current = updateTransientState(\n    transientState.current,\n    transientProps.current,\n    previousProps.current,\n    attachTouch\n  );\n\n  return handlers;\n}\n"]},"metadata":{},"sourceType":"module"}